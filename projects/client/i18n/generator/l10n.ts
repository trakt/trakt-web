import { parseArgs as parseCliArgs } from 'jsr:@std/cli/parse-args';
import { basename, dirname, isAbsolute, resolve } from 'jsr:@std/path';

interface XCStringsData {
  sourceLanguage: string;
  strings: Record<string, {
    localizations: Record<string, {
      stringUnit: {
        state: string;
        value: string;
      };
    }>;
  }>;
  version: string;
}

interface Args {
  input: string;
  output: string;
}

function getKeysAndStringsFromXcstrings(
  filePath: string,
): Record<string, string> {
  const resolvedPath = isAbsolute(filePath) ? filePath : resolve(filePath);
  const fileContent = Deno.readTextFileSync(resolvedPath);
  const data: XCStringsData = JSON.parse(fileContent);

  const result: Record<string, string> = {};
  const strings = data.strings || {};

  for (const [key, val] of Object.entries(strings)) {
    try {
      const englishLocalization = val.localizations?.en;
      if (englishLocalization?.stringUnit?.value) {
        result[key] = englishLocalization.stringUnit.value;
      }
    } catch (_error) {
      // Skip keys that don't have English localization
    }
  }

  return result;
}

function extractPlaceholderTypes(stringValue: string): string[] {
  const pattern =
    /%(\d+\$)?[+\-#0 ]*(?:\d+)?(?:\.\d+)?[hlL]?([@diufFeEgGxXoscp])/g;
  const matches = Array.from(stringValue.matchAll(pattern));

  const swiftType = (spec: string): string => {
    const typeMap: Record<string, string> = {
      'd': 'Int',
      'i': 'Int',
      'u': 'UInt',
      'f': 'Double',
      'F': 'Double',
      'e': 'Double',
      'E': 'Double',
      'g': 'Double',
      'G': 'Double',
      '@': 'String',
      'c': 'Character',
      'li': 'Int64',
      'ld': 'Int64',
    };
    return typeMap[spec] ?? 'CVarArg';
  };

  const positionals: Record<number, string> = {};
  const order: string[] = [];

  for (const match of matches) {
    const [, pos, spec] = match;
    if (!spec) continue;

    const typ = swiftType(spec);

    if (pos) {
      const index = parseInt(pos.slice(0, -1)) - 1;
      positionals[index] = typ;
    } else {
      order.push(typ);
    }
  }

  if (Object.keys(positionals).length > 0) {
    return Object.keys(positionals)
      .map((k) => parseInt(k))
      .toSorted((a, b) => a - b)
      .map((i) => positionals[i])
      .filter((type): type is string => Boolean(type));
  }

  return order;
}

function swiftifyKey(key: string): string {
  return key.replace(/[._-](\w)/g, (_, char) => char.toUpperCase());
}

function generateStrings(args: Args): void {
  const keysAndStrings = getKeysAndStringsFromXcstrings(args.input);
  const sortedKeys = Object.keys(keysAndStrings).toSorted();
  const enumName = 'L10n'; // Fixed enum name

  // Ensure output directory exists
  const resolvedOutputPath = isAbsolute(args.output)
    ? args.output
    : resolve(args.output);
  const outputDir = dirname(resolvedOutputPath);
  try {
    Deno.statSync(outputDir);
  } catch (_error) {
    Deno.mkdirSync(outputDir, { recursive: true });
  }

  const generateEnumCases = (keys: string[]): string[] => {
    return keys
      .map((key) => {
        const swiftKey = swiftifyKey(key);
        const stringValue = keysAndStrings[key];
        if (!stringValue) return '';

        const types = extractPlaceholderTypes(stringValue);
        return types.length > 0
          ? `  case ${swiftKey}(${types.join(', ')})`
          : `  case ${swiftKey}`;
      })
      .filter(Boolean);
  };

  const generateSwitchCases = (keys: string[]): string[] => {
    return keys
      .map((key) => {
        const swiftKey = swiftifyKey(key);
        const stringValue = keysAndStrings[key];
        if (!stringValue) return [];

        const types = extractPlaceholderTypes(stringValue);
        if (types.length > 0) {
          const params = Array.from(
            { length: types.length },
            (_, i) => `p${i + 1}`,
          );
          const pattern = params.map((p) => `let ${p}`).join(', ');
          const callArgs = params.join(', ');
          return [
            `    case .${swiftKey}(${pattern}):`,
            `      return ${enumName}.trFormat(key: "${key}", bundle: bundle, localeIdentifier: localeIdentifier, ${callArgs})`,
          ];
        } else {
          return [
            `    case .${swiftKey}:`,
            `      return ${enumName}.tr(key: "${key}", bundle: bundle)`,
          ];
        }
      })
      .filter(Boolean)
      .flat();
  };

  const outputLines = [
    '// swiftlint:disable all',
    '// Generated by a script, do not edit manually.',
    `// Generated from ${basename(args.input)}`,
    '',
    'import Foundation',
    '',
    `public enum ${enumName}: Equatable, Hashable {`,
    ...generateEnumCases(sortedKeys),
    '}',
    '',
    `extension ${enumName}: CustomStringConvertible {`,
    '  public var description: String { return self.string() }',
    '',
    '  public func string(bundle: Bundle = .main, localeIdentifier: String? = nil) -> String {',
    '    switch self {',
    ...generateSwitchCases(sortedKeys),
    '    }',
    '  }',
    '',
    '  private static func tr(key: String, bundle: Bundle) -> String {',
    '    bundle.localizedString(forKey: key, value: key, table: nil)',
    '  }',
    '',
    '  private static func trFormat(key: String, bundle: Bundle, localeIdentifier: String?, _ args: CVarArg...) -> String {',
    '    let format = bundle.localizedString(forKey: key, value: key, table: nil)',
    '    return String(format: format, locale: localeIdentifier.map { .init(identifier: $0) } ?? .current, arguments: args)',
    '  }',
    '}',
    '\n',
  ];

  const output = outputLines.join('\n');

  Deno.writeTextFileSync(resolvedOutputPath, output);
  console.log(
    `Generated ${resolvedOutputPath} with ${sortedKeys.length} keys.`,
  );
}

function parseArgs(): Args {
  const flags = parseCliArgs(Deno.args, {
    string: ['input', 'output'],
    default: {
      'input': 'Localizable.xcstrings',
      'output': 'L10n.swift',
    },
    alias: {
      'i': 'input',
      'o': 'output',
    },
  });

  return {
    input: flags.input,
    output: flags.output,
  };
}

function main(): void {
  const args = parseArgs();
  generateStrings(args);
}

if (import.meta.main) {
  main();
}
